/**
 * AI-Generated Test Suite for toNumber function
 *
 * Generated by: Claude (Anthropic) via Cursor IDE
 * Date: December 8, 2025
 *
 * This test suite was generated using AI assistance based on the test plan
 * from Phase 1 of the assignment. The AI was prompted to cover all planned
 * test cases plus identify additional edge cases that may have been missed.
 *
 * Oracle: The expected behavior is derived from:
 * 1. The function's JSDoc documentation
 * 2. Lodash toNumber specification (as this is a lodash-based utility)
 * 3. JavaScript Number coercion rules and IEEE 754 floating-point semantics
 */

import toNumber from "../../src/toNumber.js";

describe("toNumber - AI Generated Tests", () => {
  // ============================================================
  // TEST CASES FROM PHASE 1 TEST PLAN
  // These tests directly implement the planned test cases
  // ============================================================

  describe("Planned Test Cases from Phase 1", () => {
    // Test Case 2.1: float as input
    test("TC 2.1: Should return 3.2 when float 3.2 is provided", () => {
      expect(toNumber(3.2)).toBe(3.2);
    });

    // Test Case 2.2: string as input
    test("TC 2.2: Should return 3.2 when string '3.2' is provided", () => {
      expect(toNumber("3.2")).toBe(3.2);
    });

    // Test Case 2.3: binary as input
    test("TC 2.3: Should return 5 when binary string '0b101' is provided", () => {
      expect(toNumber("0b101")).toBe(5);
    });

    // Test Case 2.4: octal as input
    test("TC 2.4: Should return 15 when octal string '0o17' is provided", () => {
      expect(toNumber("0o17")).toBe(15);
    });

    // Test Case 2.5: leading whitespace
    test("TC 2.5: Should return 1 when string with leading whitespace ' 1' is provided", () => {
      expect(toNumber(" 1")).toBe(1);
    });

    // Test Case 2.6: boolean as input
    test("TC 2.6: Should return 1 when boolean true is provided", () => {
      expect(toNumber(true)).toBe(1);
    });

    // Test Case 2.7: null as input
    test("TC 2.7: Should return 0 when null is provided", () => {
      expect(toNumber(null)).toBe(0);
    });

    // Test Case 2.8: bad hex as input (negative)
    test("TC 2.8: Should return NaN when bad hex '-0x123' is provided", () => {
      expect(toNumber("-0x123")).toBeNaN();
    });

    // Test Case 2.9: invalid string as input (negative)
    test("TC 2.9: Should return NaN when invalid string 'hello' is provided", () => {
      expect(toNumber("hello")).toBeNaN();
    });

    // Test Case 2.10: empty string as input (boundary)
    test("TC 2.10: Should return 0 when empty string '' is provided", () => {
      expect(toNumber("")).toBe(0);
    });
  });

  // ============================================================
  // ADDITIONAL AI-IDENTIFIED EDGE CASES
  // These tests cover scenarios not explicitly in the Phase 1 plan
  // ============================================================

  describe("Additional Edge Cases - Number Inputs", () => {
    test("Should return 0 when 0 is provided", () => {
      expect(toNumber(0)).toBe(0);
    });

    test("Should return -0 when -0 is provided", () => {
      expect(Object.is(toNumber(-0), -0)).toBe(true);
    });

    test("Should return negative number when negative number is provided", () => {
      expect(toNumber(-42)).toBe(-42);
    });

    test("Should return integer when integer is provided", () => {
      expect(toNumber(42)).toBe(42);
    });

    test("Should return Infinity when Infinity is provided", () => {
      expect(toNumber(Infinity)).toBe(Infinity);
    });

    test("Should return -Infinity when -Infinity is provided", () => {
      expect(toNumber(-Infinity)).toBe(-Infinity);
    });

    test("Should return NaN when NaN is provided", () => {
      expect(toNumber(NaN)).toBeNaN();
    });

    test("Should return Number.MAX_VALUE when Number.MAX_VALUE is provided", () => {
      expect(toNumber(Number.MAX_VALUE)).toBe(Number.MAX_VALUE);
    });

    test("Should return Number.MIN_VALUE when Number.MIN_VALUE is provided", () => {
      expect(toNumber(Number.MIN_VALUE)).toBe(Number.MIN_VALUE);
    });

    test("Should return Number.MAX_SAFE_INTEGER when provided", () => {
      expect(toNumber(Number.MAX_SAFE_INTEGER)).toBe(Number.MAX_SAFE_INTEGER);
    });

    test("Should return Number.MIN_SAFE_INTEGER when provided", () => {
      expect(toNumber(Number.MIN_SAFE_INTEGER)).toBe(Number.MIN_SAFE_INTEGER);
    });
  });

  describe("Additional Edge Cases - Boolean Inputs", () => {
    test("Should return 0 when false is provided", () => {
      expect(toNumber(false)).toBe(0);
    });

    test("Should return 1 when Boolean object (true) is provided", () => {
      expect(toNumber(new Boolean(true))).toBe(1);
    });

    test("Should return 0 when Boolean object (false) is provided", () => {
      expect(toNumber(new Boolean(false))).toBe(0);
    });
  });

  describe("Additional Edge Cases - String Inputs", () => {
    test("Should return number when string with trailing whitespace is provided", () => {
      expect(toNumber("42 ")).toBe(42);
    });

    test("Should return number when string with both leading and trailing whitespace is provided", () => {
      expect(toNumber("  42  ")).toBe(42);
    });

    test("Should return number when string with tabs is provided", () => {
      expect(toNumber("\t42\t")).toBe(42);
    });

    test("Should return number when string with newlines is provided", () => {
      expect(toNumber("\n42\n")).toBe(42);
    });

    test("Should return negative number from negative string", () => {
      expect(toNumber("-42")).toBe(-42);
    });

    test("Should return number from string with explicit positive sign", () => {
      expect(toNumber("+42")).toBe(42);
    });

    test("Should return float from negative float string", () => {
      expect(toNumber("-3.14")).toBe(-3.14);
    });

    test("Should return number from scientific notation string", () => {
      expect(toNumber("1e10")).toBe(1e10);
    });

    test("Should return number from negative scientific notation string", () => {
      expect(toNumber("-1e10")).toBe(-1e10);
    });

    test("Should return number from scientific notation with positive exponent", () => {
      expect(toNumber("1e+10")).toBe(1e10);
    });

    test("Should return small number from scientific notation with negative exponent", () => {
      expect(toNumber("1e-10")).toBe(1e-10);
    });

    test("Should return Infinity from string 'Infinity'", () => {
      expect(toNumber("Infinity")).toBe(Infinity);
    });

    test("Should return -Infinity from string '-Infinity'", () => {
      expect(toNumber("-Infinity")).toBe(-Infinity);
    });

    test("Should return 0 from whitespace-only string", () => {
      expect(toNumber("   ")).toBe(0);
    });
  });

  describe("Additional Edge Cases - Hexadecimal Strings", () => {
    test("Should return number from valid hex string '0xFF'", () => {
      expect(toNumber("0xFF")).toBe(255);
    });

    test("Should return number from valid hex string '0x10'", () => {
      expect(toNumber("0x10")).toBe(16);
    });

    test("Should return number from lowercase hex string '0xff'", () => {
      expect(toNumber("0xff")).toBe(255);
    });

    test("Should return NaN from positive signed hex string '+0x10'", () => {
      expect(toNumber("+0x10")).toBeNaN();
    });

    test("Should return NaN from hex string with invalid characters", () => {
      expect(toNumber("0xGG")).toBeNaN();
    });
  });

  describe("Additional Edge Cases - Binary Strings", () => {
    test("Should return 0 from binary string '0b0'", () => {
      expect(toNumber("0b0")).toBe(0);
    });

    test("Should return 1 from binary string '0b1'", () => {
      expect(toNumber("0b1")).toBe(1);
    });

    test("Should return 255 from binary string '0b11111111'", () => {
      expect(toNumber("0b11111111")).toBe(255);
    });

    test("Should return NaN from invalid binary string '0b102'", () => {
      expect(toNumber("0b102")).toBeNaN();
    });

    test("Should handle uppercase B in binary '0B101'", () => {
      expect(toNumber("0B101")).toBe(5);
    });
  });

  describe("Additional Edge Cases - Octal Strings", () => {
    test("Should return 0 from octal string '0o0'", () => {
      expect(toNumber("0o0")).toBe(0);
    });

    test("Should return 7 from octal string '0o7'", () => {
      expect(toNumber("0o7")).toBe(7);
    });

    test("Should return 63 from octal string '0o77'", () => {
      expect(toNumber("0o77")).toBe(63);
    });

    test("Should return NaN from invalid octal string '0o78'", () => {
      expect(toNumber("0o78")).toBeNaN();
    });

    test("Should handle uppercase O in octal '0O17'", () => {
      expect(toNumber("0O17")).toBe(15);
    });
  });

  describe("Additional Edge Cases - Null and Undefined", () => {
    test("Should return NaN when undefined is provided", () => {
      expect(toNumber(undefined)).toBeNaN();
    });

    test("Should return 0 when null is provided (duplicate for emphasis)", () => {
      expect(toNumber(null)).toBe(0);
    });
  });

  describe("Additional Edge Cases - Symbol Inputs", () => {
    test("Should return NaN when Symbol is provided", () => {
      expect(toNumber(Symbol("test"))).toBeNaN();
    });

    test("Should return NaN when well-known Symbol is provided", () => {
      expect(toNumber(Symbol.iterator)).toBeNaN();
    });
  });

  describe("Additional Edge Cases - Object Inputs", () => {
    test("Should return number from object with valueOf returning number", () => {
      const obj = { valueOf: () => 42 };
      expect(toNumber(obj)).toBe(42);
    });

    test("Should return number from object with valueOf returning string number", () => {
      const obj = { valueOf: () => "42" };
      expect(toNumber(obj)).toBe(42);
    });

    test("Should return NaN from plain object without valueOf", () => {
      expect(toNumber({ a: 1 })).toBeNaN();
    });

    test("Should return NaN from empty object", () => {
      expect(toNumber({})).toBeNaN();
    });

    test("Should return number from Number object", () => {
      expect(toNumber(new Number(42))).toBe(42);
    });

    test("Should return number from Date object (timestamp)", () => {
      const date = new Date("2024-01-01T00:00:00.000Z");
      expect(toNumber(date)).toBe(date.getTime());
    });

    test("Should return NaN from object with valueOf returning object", () => {
      const obj = { valueOf: () => ({}) };
      expect(toNumber(obj)).toBeNaN();
    });

    test("Should handle object with toString but no valueOf", () => {
      const obj = {
        toString: () => "42",
        valueOf: () => obj, // returns itself
      };
      expect(toNumber(obj)).toBe(42);
    });

    // Additional tests for uncovered branches
    test("Should handle object without valueOf function (valueOf is not a function)", () => {
      // Create object with valueOf set to a non-function value
      const obj = Object.create(null);
      obj.valueOf = "not a function";
      obj.toString = () => "42";
      expect(toNumber(obj)).toBe(42);
    });

    test("Should handle object with valueOf explicitly set to undefined", () => {
      const obj = { valueOf: undefined, toString: () => "99" };
      expect(toNumber(obj)).toBe(99);
    });

    test("Should handle object with valueOf returning 0", () => {
      const obj = { valueOf: () => 0 };
      // This should return 0 (via line 56: value === 0 ? value : +value)
      expect(toNumber(obj)).toBe(0);
    });

    test("Should preserve -0 from object valueOf", () => {
      const obj = { valueOf: () => -0 };
      expect(Object.is(toNumber(obj), -0)).toBe(true);
    });
  });

  describe("Additional Edge Cases - Array Inputs", () => {
    test("Should return 0 from empty array", () => {
      expect(toNumber([])).toBe(0);
    });

    test("Should return number from single-element number array", () => {
      expect(toNumber([42])).toBe(42);
    });

    test("Should return number from single-element string array", () => {
      expect(toNumber(["42"])).toBe(42);
    });

    test("Should return NaN from multi-element array", () => {
      expect(toNumber([1, 2, 3])).toBeNaN();
    });

    test("Should return NaN from array with non-numeric string", () => {
      expect(toNumber(["hello"])).toBeNaN();
    });

    test("Should return 0 from array with null", () => {
      expect(toNumber([null])).toBe(0);
    });

    test("Should return 0 from nested empty arrays", () => {
      expect(toNumber([[]])).toBe(0);
    });
  });

  describe("Additional Edge Cases - Function Inputs", () => {
    test("Should return NaN from function", () => {
      expect(toNumber(function () {})).toBeNaN();
    });

    test("Should return NaN from arrow function", () => {
      expect(toNumber(() => {})).toBeNaN();
    });
  });

  describe("Additional Edge Cases - String Edge Cases", () => {
    test("Should return NaN from string with number and text", () => {
      expect(toNumber("42abc")).toBeNaN();
    });

    test("Should return NaN from string with text and number", () => {
      expect(toNumber("abc42")).toBeNaN();
    });

    test("Should handle string '0'", () => {
      expect(toNumber("0")).toBe(0);
    });

    test("Should handle string '-0'", () => {
      expect(Object.is(toNumber("-0"), -0)).toBe(true);
    });

    test("Should return number from string '.5' (leading decimal)", () => {
      expect(toNumber(".5")).toBe(0.5);
    });

    test("Should return number from string '5.' (trailing decimal)", () => {
      expect(toNumber("5.")).toBe(5);
    });

    test("Should return NaN from multiple decimal points", () => {
      expect(toNumber("3.14.15")).toBeNaN();
    });

    test("Should handle very long number string", () => {
      expect(toNumber("12345678901234567890")).toBe(12345678901234567890);
    });
  });

  // ============================================================
  // E-COMMERCE CONTEXT TESTS
  // Tests relevant to the e-commerce application scenarios
  // ============================================================

  describe("E-Commerce Context Tests", () => {
    test("Should correctly convert product price string to number", () => {
      const priceString = "29.99";
      expect(toNumber(priceString)).toBeCloseTo(29.99, 2);
    });

    test("Should correctly convert quantity string to number", () => {
      const quantityString = "5";
      expect(toNumber(quantityString)).toBe(5);
    });

    test("Should correctly convert discount percentage string", () => {
      const discountString = "15.5";
      expect(toNumber(discountString)).toBeCloseTo(15.5, 2);
    });

    test("Should handle price with leading/trailing whitespace from form input", () => {
      const formInput = "  99.99  ";
      expect(toNumber(formInput)).toBeCloseTo(99.99, 2);
    });

    test("Should return NaN for invalid price input", () => {
      const invalidPrice = "$29.99"; // Dollar sign makes it invalid
      expect(toNumber(invalidPrice)).toBeNaN();
    });

    test("Should handle stock quantity as number", () => {
      const stockQuantity = 100;
      expect(toNumber(stockQuantity)).toBe(100);
    });

    test("Should handle zero stock correctly", () => {
      expect(toNumber(0)).toBe(0);
      expect(toNumber("0")).toBe(0);
    });

    test("Should correctly convert cart total calculation result", () => {
      // Simulating a cart total that might come as a calculated value
      const cartTotal = 149.97;
      expect(toNumber(cartTotal)).toBeCloseTo(149.97, 2);
    });

    test("Should handle shipping cost string", () => {
      const shippingCost = "4.99";
      expect(toNumber(shippingCost)).toBeCloseTo(4.99, 2);
    });

    test("Should handle tax rate decimal", () => {
      const taxRate = 0.24; // 24% VAT
      expect(toNumber(taxRate)).toBeCloseTo(0.24, 2);
    });

    test("Should handle product rating from API response", () => {
      const ratingString = "4.5";
      expect(toNumber(ratingString)).toBeCloseTo(4.5, 1);
    });

    test("Should handle page number for pagination", () => {
      const pageNumber = "3";
      expect(toNumber(pageNumber)).toBe(3);
    });

    test("Should handle items per page setting", () => {
      const itemsPerPage = "25";
      expect(toNumber(itemsPerPage)).toBe(25);
    });
  });

  describe("Precision and Floating Point Tests", () => {
    test("Should handle common floating point precision issues", () => {
      // This tests the classic 0.1 + 0.2 !== 0.3 scenario
      const result = toNumber("0.1");
      expect(result).toBeCloseTo(0.1, 10);
    });

    test("Should handle currency-like precision (2 decimals)", () => {
      expect(toNumber("19.99")).toBeCloseTo(19.99, 2);
    });

    test("Should handle very small decimals", () => {
      expect(toNumber("0.001")).toBeCloseTo(0.001, 4);
    });

    test("Should handle trailing zeros", () => {
      expect(toNumber("10.00")).toBe(10);
    });

    test("Should handle many decimal places", () => {
      expect(toNumber("3.141592653589793")).toBeCloseTo(Math.PI, 15);
    });
  });
});
